/*
 * i2c.c
 *
 *  Created on: Sep 27, 2025
 *      Author: garrettfalast
 */

#include "stm32f4xx.h"

#define GPIOBEN 				(1U<<1)
#define I2C1EN					(1U<<21)

#define I2C_100KHZ				(80) // Decimal 80
#define SD_MODE_MAX_RISE_TIME	17
#define CR1_PE					(1U<<0)

#define SR2_BUSY				(1U<<1)
#define CR1_START				(1U<<8)
#define SR1_SB					(1U<<0)
#define SR1_ADDR				(1U<<1)
#define SR1_TXE					(1U<<7)
#define CR1_ACK					(1U<<10)
#define SR1_RXNE				(1U<<6)


// pinout
// PB8: SCL
// PB9: SDA
void I2C1_init(void) {

	// enable clock access to GPIOB
	RCC->AHB1ENR |= GPIOBEN;

	// set PB8 and PB9 mode to alternate function
	GPIOB->MODER &= ~(1U<<16);
	GPIOB->MODER |= (1U<<17);

	GPIOB->MODER &= ~(1U<<18);
	GPIOB->MODER |= (1U<<19);

	// Set PB8 and PB9 output type to open drain
	GPIOB->OTYPER |= (1U<<8);
	GPIOB->OTYPER |= (1U<<9);

	// enable Pull-up for PB8 and PB9
	GPIOB->PUPDR |= (1U<<16);
	GPIOB->PUPDR &= ~(1U<<17);

	GPIOB->PUPDR |= (1U<<18);
	GPIOB->PUPDR &= ~(1U<<19);

	// enable clock access to I2C1
	RCC->APB1ENR |= I2C1EN;

	// enter reset mode
	I2C1->CR1 |= (1U<<15);

	// exit reset mode
	I2C1->CR1 &= ~(1U<<15);

	// set peripheral clock frequency
	I2C1->CR2 = (1U<<4);

	// set I2C to standard mode, 100khz clock
	I2C1->CCR = I2C_100KHZ;

	// set rise time
	I2C1->TRISE = SD_MODE_MAX_RISE_TIME;

	// enable I2C1 module
	I2C1->CR1 |= CR1_PE;

}

void I2C1_byte_read(char saddr, char maddr, char *data) {

	volatile int tmp;

	// wait until device bus not busy
	while (I2C1->SR2 & (SR2_BUSY)) {}

	// generate a start condition
	I2C1->CR1 |= CR1_START;

	// wait until start flag is set
	while (!(I2C1->SR1 & SR1_SB)) {}

	// transmit slave address
	I2C1->DR = saddr << 1;

	// wait until address flag is set
	while (!(I2C1->SR1 & SR1_ADDR)) {}

	// clear address flag
	tmp = I2C1->SR2;

	// send memory address
	I2C1->DR = maddr;

	// wait until transmitter is empty
	while (!(I2C1->SR1 & SR1_TXE)) {}

	// generate a restart condition
	I2C1->CR1 |= CR1_START;

	// wait until start flag is set
	while (!(I2C1->SR1 & SR1_SB)) {}

	// transmit slave address and read
	I2C1->DR = saddr<<1 | 1;

	// wait until address flag is set
	while (!(I2C1->SR1 & SR1_ADDR)) {}

	// disable acknowledgement
	I2C1->CR1 &= ~(CR1_ACK);

	// clear address flag
	tmp = I2C1->SR2;

	// generate stop after data receieved
	I2C1->CR1 |= CR1_STOP;

	// wait until RXNE flag is set
	while (!(I2C1->SR1 & SR_RXNE)) {}

	// read data from DR
	*data++ = I2C1->DR;
}

void I2C1_burst_read(char saddr, char maddr, char *data) {

	volatile int tmp;

	// wait until device bus not busy
	while (I2C1->SR2 & (SR2_BUSY)) {}

	// generate a start condition
	I2C1->CR1 |= CR1_START;

	// wait until start flag is set
	while (!(I2C1->SR1 & SR1_SB)) {}



}













