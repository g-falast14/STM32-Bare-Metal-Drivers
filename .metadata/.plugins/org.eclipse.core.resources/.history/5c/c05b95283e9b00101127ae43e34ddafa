#include "uart.h"

/*
 * uart.c
 *
 *  Created on: Sep 25, 2025
 *      Author: garrettfalast
 */

#define GPIOAEN			(1U<<0)
#define UART2EN			(1U<<17)

#define CR1_TE			(1U<<3)
#define CR1_UE			(1U<<13)

#define CR1_RE 			(1U<<2)
#define SR_TXE			(1U<<7)
#define CR1_RXNEIE		(1U<<5)

#define SYS_FREQ		16000000 //16mhz, 16mil cycles per second
#define APB1_CLK		SYS_FREQ

#define UART_BAUDRATE	115200

#define DMA1EN			(1U<<21)
#define DMA_S_EN		(1U<<0)

static void uart_set_baudrate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t BaudRate);
static uint16_t compute_uart_bd(uint32_t PeriphClk, uint32_t BaudRate);
void uart2_write(int ch);
char uart2_read(void);
void uart2_tx_init(void);
int __io_putchar(int ch);


int __io_putchar(int ch) {
	uart2_write(ch);
	return ch;
}

void dma1_stream6_init(uint32_t source, uint32_t destination, uint32_t length) {
	// enable clock access to dma
	RCC->AHB1ENR |= DMA1EN;

	// disable dma1 stream6
	DMA1_Stream6->CR &= ~(DMA_S_EN);

	// clear all stream6 interrupt flags
	DMA1->HIFCR |= (1U<<16);
	DMA1->HIFCR |= (1U<<18);
	DMA1->HIFCR |= (1U<<19);
	DMA1->HIFCR |= (1U<<20);
	DMA1->HIFCR |= (1U<<21);

	// set the destination buffer
	DMA1_Stream6->PAR = destination;

	// set the source buffer
	DMA1_Stream6->M0AR = source;

	// set length
	DMA1_Stream6->NDTR = length;

	// select stream6 ch4

	// enable memory increment

	// configure transfer direction

	// enable direct mode, disable FIFO

	// enable dma1 stream6

	// enable UART2 transmitter dma

	// dma interrupt enable in NVIC
}

void uart2_rxtx_init(void) {

	// configure the uart gpio pin
		// enable clock access to gpioa
		RCC->AHB1ENR |= GPIOAEN;

		// set PA2 mode to alternate function mode
		GPIOA->MODER &= ~(1U<<4);
		GPIOA->MODER |= (1U<<5);

		// set PA2 alternate function type to UART_TX (AF07)
		GPIOA->AFR[0] |= (1U<<8);
		GPIOA->AFR[0] |= (1U<<9);
		GPIOA->AFR[0] |= (1U<<10);
		GPIOA->AFR[0] &= ~(1U<<11);

		// set PA3 alternate function type to UART_RX (AF07)
		GPIOA->MODER &= ~(1U<<6);
		GPIOA->MODER |= (1U<<7);

		// set PA2 alternate function type to UART_TX (AF07)
		GPIOA->AFR[0] |= (1U<<12);
		GPIOA->AFR[0] |= (1U<<13);
		GPIOA->AFR[0] |= (1U<<14);
		GPIOA->AFR[0] &= ~(1U<<15);

		// configure uart module
		// enable clock access to uart2
		RCC->APB1ENR |= UART2EN;

		// configure baudrate
		uart_set_baudrate(USART2, APB1_CLK, UART_BAUDRATE);

		// configure the transfer direction
		USART2->CR1 = (CR1_TE | CR1_RE);

		// enable the uart module
		USART2->CR1 |= CR1_UE;
}

void uart2_rx_interrupt_init(void) {

	// configure the uart gpio pin
		// enable clock access to gpioa
		RCC->AHB1ENR |= GPIOAEN;

		// set PA2 mode to alternate function mode
		GPIOA->MODER &= ~(1U<<4);
		GPIOA->MODER |= (1U<<5);

		// set PA2 alternate function type to UART_TX (AF07)
		GPIOA->AFR[0] |= (1U<<8);
		GPIOA->AFR[0] |= (1U<<9);
		GPIOA->AFR[0] |= (1U<<10);
		GPIOA->AFR[0] &= ~(1U<<11);

		// set PA3 alternate function type to UART_RX (AF07)
		GPIOA->MODER &= ~(1U<<6);
		GPIOA->MODER |= (1U<<7);

		// set PA2 alternate function type to UART_TX (AF07)
		GPIOA->AFR[0] |= (1U<<12);
		GPIOA->AFR[0] |= (1U<<13);
		GPIOA->AFR[0] |= (1U<<14);
		GPIOA->AFR[0] &= ~(1U<<15);

		// configure uart module
		// enable clock access to uart2
		RCC->APB1ENR |= UART2EN;

		// configure baudrate
		uart_set_baudrate(USART2, APB1_CLK, UART_BAUDRATE);

		// configure the transfer direction
		USART2->CR1 = (CR1_TE | CR1_RE);

		// enable RXNE interrupt
		USART2->CR1 |= CR1_RXNEIE;

		// enable UART2 interrupt in NVIC
		NVIC_EnableIRQ(USART2_IRQn);

		// enable the uart module
		USART2->CR1 |= CR1_UE;
}

char uart2_read(void) {

	// make sure receive data register is not empty
	while(!(USART2->SR & SR_TXE)) {}

	return USART2->DR;

}


void uart2_write(int ch) {

	// make sure transmit data register is empty
	while(!(USART2->SR & SR_TXE)) {}

	// write to transmit data register
	USART2->DR = (ch & 0xFF);

}


static void uart_set_baudrate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t BaudRate) {
	USARTx->BRR = compute_uart_bd(PeriphClk, BaudRate);
}

static uint16_t compute_uart_bd(uint32_t PeriphClk, uint32_t BaudRate) {
	return ((PeriphClk + (BaudRate/2U))/BaudRate);
}
